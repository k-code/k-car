   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"stm32f4xx_pwr.c"
  23              	.Ltext0:
  24              		.file 1 "../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c"
 24632              		.align	2
 24633              		.global	PWR_DeInit
 24634              		.thumb
 24635              		.thumb_func
 24637              	PWR_DeInit:
 24638              	.LFB110:
   1:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
   2:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   ******************************************************************************
   3:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @file    stm32f4xx_pwr.c
   4:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @author  MCD Application Team
   5:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @version V1.0.0
   6:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @date    30-September-2011
   7:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief   This file provides firmware functions to manage the following 
   8:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:           
   9:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *           - Backup Domain Access
  10:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *           - PVD configuration
  11:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *           - WakeUp pin configuration
  12:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *           - Main and Backup Regulators configuration
  13:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *           - FLASH Power Down configuration
  14:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *           - Low Power modes configuration
  15:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *           - Flags management
  16:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *               
  17:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   ******************************************************************************
  18:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @attention
  19:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *
  20:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  21:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  22:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  23:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  24:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  25:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  26:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *
  27:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
  28:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   ******************************************************************************
  29:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */ 
  30:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  31:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Includes ------------------------------------------------------------------*/
  32:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #include "stm32f4xx_pwr.h"
  33:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #include "stm32f4xx_rcc.h"
  34:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  35:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /** @addtogroup STM32F4xx_StdPeriph_Driver
  36:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @{
  37:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
  38:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  39:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /** @defgroup PWR 
  40:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief PWR driver modules
  41:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @{
  42:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */ 
  43:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  44:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  45:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Private define ------------------------------------------------------------*/
  46:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* --------- PWR registers bit address in the alias region ---------- */
  47:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
  48:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  49:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* --- CR Register ---*/
  50:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  51:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Alias word address of DBP bit */
  52:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define CR_OFFSET                (PWR_OFFSET + 0x00)
  53:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define DBP_BitNumber            0x08
  54:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
  55:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  56:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Alias word address of PVDE bit */
  57:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define PVDE_BitNumber           0x04
  58:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
  59:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  60:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Alias word address of FPDS bit */
  61:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define FPDS_BitNumber           0x09
  62:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define CR_FPDS_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (FPDS_BitNumber * 4))
  63:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  64:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Alias word address of PMODE bit */
  65:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define PMODE_BitNumber           0x0E
  66:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define CR_PMODE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PMODE_BitNumber * 4))
  67:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  68:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  69:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* --- CSR Register ---*/
  70:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  71:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Alias word address of EWUP bit */
  72:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define CSR_OFFSET               (PWR_OFFSET + 0x04)
  73:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define EWUP_BitNumber           0x08
  74:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
  75:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  76:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Alias word address of BRE bit */
  77:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define BRE_BitNumber            0x09
  78:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define CSR_BRE_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (BRE_BitNumber * 4))
  79:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  80:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* ------------------ PWR registers bit mask ------------------------ */
  81:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  82:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* CR register bit mask */
  83:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define CR_DS_MASK               ((uint32_t)0xFFFFFFFC)
  84:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)
  85:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  86:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Private macro -------------------------------------------------------------*/
  87:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Private variables ---------------------------------------------------------*/
  88:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Private function prototypes -----------------------------------------------*/
  89:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* Private functions ---------------------------------------------------------*/
  90:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  91:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Private_Functions
  92:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @{
  93:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
  94:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
  95:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group1 Backup Domain Access function 
  96:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *  @brief   Backup Domain Access function  
  97:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *
  98:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @verbatim   
  99:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================
 100:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****                             Backup Domain Access function 
 101:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================  
 102:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 103:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   After reset, the backup domain (RTC registers, RTC backup data 
 104:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   registers and backup SRAM) is protected against possible unwanted 
 105:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   write accesses. 
 106:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   To enable access to the RTC Domain and RTC registers, proceed as follows:
 107:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     - Enable the Power Controller (PWR) APB1 interface clock using the
 108:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****       RCC_APB1PeriphClockCmd() function.
 109:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     - Enable access to RTC domain using the PWR_BackupAccessCmd() function.
 110:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 111:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @endverbatim
 112:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @{
 113:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 114:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 115:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 116:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.     
 117:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  None
 118:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @retval None
 119:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 120:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** void PWR_DeInit(void)
 121:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** {
 24639              		.loc 1 121 0
 24640              		.cfi_startproc
 24641              		@ args = 0, pretend = 0, frame = 0
 24642              		@ frame_needed = 1, uses_anonymous_args = 0
 24643 0000 80B5     		push	{r7, lr}
 24644              	.LCFI0:
 24645              		.cfi_def_cfa_offset 8
 24646 0002 00AF     		add	r7, sp, #0
 24647              		.cfi_offset 14, -4
 24648              		.cfi_offset 7, -8
 24649              	.LCFI1:
 24650              		.cfi_def_cfa_register 7
 122:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 24651              		.loc 1 122 0
 24652 0004 4FF08050 		mov	r0, #268435456
 24653 0008 4FF00101 		mov	r1, #1
 24654 000c FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 123:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
 24655              		.loc 1 123 0
 24656 0010 4FF08050 		mov	r0, #268435456
 24657 0014 4FF00001 		mov	r1, #0
 24658 0018 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 124:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** }
 24659              		.loc 1 124 0
 24660 001c 80BD     		pop	{r7, pc}
 24661              		.cfi_endproc
 24662              	.LFE110:
 24664 001e 00BF     		.section	.text.PWR_BackupAccessCmd,"ax",%progbits
 24665              		.align	2
 24666              		.global	PWR_BackupAccessCmd
 24667              		.thumb
 24668              		.thumb_func
 24670              	PWR_BackupAccessCmd:
 24671              	.LFB111:
 125:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 126:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 127:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables access to the backup domain (RTC registers, RTC 
 128:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *         backup data registers and backup SRAM).
 129:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
 130:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *         Backup Domain Access should be kept enabled.
 131:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the access to the backup domain.
 132:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 133:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @retval None
 134:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 135:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** void PWR_BackupAccessCmd(FunctionalState NewState)
 136:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** {
 24672              		.loc 1 136 0
 24673              		.cfi_startproc
 24674              		@ args = 0, pretend = 0, frame = 8
 24675              		@ frame_needed = 1, uses_anonymous_args = 0
 24676              		@ link register save eliminated.
 24677 0000 80B4     		push	{r7}
 24678              	.LCFI2:
 24679              		.cfi_def_cfa_offset 4
 24680 0002 83B0     		sub	sp, sp, #12
 24681              	.LCFI3:
 24682              		.cfi_def_cfa_offset 16
 24683 0004 00AF     		add	r7, sp, #0
 24684              		.cfi_offset 7, -4
 24685              	.LCFI4:
 24686              		.cfi_def_cfa_register 7
 24687 0006 0346     		mov	r3, r0
 24688 0008 FB71     		strb	r3, [r7, #7]
 137:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 138:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 139:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 140:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 24689              		.loc 1 140 0
 24690 000a 044B     		ldr	r3, .L3
 24691 000c FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 24692 000e 1A60     		str	r2, [r3, #0]
 141:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** }
 24693              		.loc 1 141 0
 24694 0010 07F10C07 		add	r7, r7, #12
 24695 0014 BD46     		mov	sp, r7
 24696 0016 80BC     		pop	{r7}
 24697 0018 7047     		bx	lr
 24698              	.L4:
 24699 001a 00BF     		.align	2
 24700              	.L3:
 24701 001c 20000E42 		.word	1108213792
 24702              		.cfi_endproc
 24703              	.LFE111:
 24705              		.section	.text.PWR_PVDLevelConfig,"ax",%progbits
 24706              		.align	2
 24707              		.global	PWR_PVDLevelConfig
 24708              		.thumb
 24709              		.thumb_func
 24711              	PWR_PVDLevelConfig:
 24712              	.LFB112:
 142:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 143:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 144:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @}
 145:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 146:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 147:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group2 PVD configuration functions
 148:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *  @brief   PVD configuration functions 
 149:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *
 150:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @verbatim   
 151:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================
 152:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****                            PVD configuration functions
 153:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================  
 154:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 155:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  - The PVD is used to monitor the VDD power supply by comparing it to a threshold
 156:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
 157:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  - A PVDO flag is available to indicate if VDD/VDDA is higher or lower than the 
 158:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    PVD threshold. This event is internally connected to the EXTI line16
 159:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    and can generate an interrupt if enabled through the EXTI registers.
 160:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  - The PVD is stopped in Standby mode.
 161:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 162:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @endverbatim
 163:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @{
 164:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 165:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 166:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 167:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 168:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  PWR_PVDLevel: specifies the PVD detection level
 169:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 170:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_0: PVD detection level set to 2.0V
 171:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_1: PVD detection level set to 2.2V
 172:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_2: PVD detection level set to 2.3V
 173:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_3: PVD detection level set to 2.5V
 174:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_4: PVD detection level set to 2.7V
 175:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_5: PVD detection level set to 2.8V
 176:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_6: PVD detection level set to 2.9V
 177:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_7: PVD detection level set to 3.0V
 178:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @note   Refer to the electrical characteristics of you device datasheet for more details. 
 179:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @retval None
 180:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 181:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
 182:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** {
 24713              		.loc 1 182 0
 24714              		.cfi_startproc
 24715              		@ args = 0, pretend = 0, frame = 16
 24716              		@ frame_needed = 1, uses_anonymous_args = 0
 24717              		@ link register save eliminated.
 24718 0000 80B4     		push	{r7}
 24719              	.LCFI5:
 24720              		.cfi_def_cfa_offset 4
 24721 0002 85B0     		sub	sp, sp, #20
 24722              	.LCFI6:
 24723              		.cfi_def_cfa_offset 24
 24724 0004 00AF     		add	r7, sp, #0
 24725              		.cfi_offset 7, -4
 24726              	.LCFI7:
 24727              		.cfi_def_cfa_register 7
 24728 0006 7860     		str	r0, [r7, #4]
 183:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 24729              		.loc 1 183 0
 24730 0008 4FF00003 		mov	r3, #0
 24731 000c FB60     		str	r3, [r7, #12]
 184:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 185:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 186:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
 187:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 188:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
 24732              		.loc 1 188 0
 24733 000e 0A4B     		ldr	r3, .L6
 24734 0010 1B68     		ldr	r3, [r3, #0]
 24735 0012 FB60     		str	r3, [r7, #12]
 189:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 190:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Clear PLS[7:5] bits */
 191:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   tmpreg &= CR_PLS_MASK;
 24736              		.loc 1 191 0
 24737 0014 FB68     		ldr	r3, [r7, #12]
 24738 0016 23F0E003 		bic	r3, r3, #224
 24739 001a FB60     		str	r3, [r7, #12]
 192:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 193:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Set PLS[7:5] bits according to PWR_PVDLevel value */
 194:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   tmpreg |= PWR_PVDLevel;
 24740              		.loc 1 194 0
 24741 001c FA68     		ldr	r2, [r7, #12]
 24742 001e 7B68     		ldr	r3, [r7, #4]
 24743 0020 42EA0303 		orr	r3, r2, r3
 24744 0024 FB60     		str	r3, [r7, #12]
 195:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 196:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Store the new value */
 197:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 24745              		.loc 1 197 0
 24746 0026 044B     		ldr	r3, .L6
 24747 0028 FA68     		ldr	r2, [r7, #12]
 24748 002a 1A60     		str	r2, [r3, #0]
 198:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** }
 24749              		.loc 1 198 0
 24750 002c 07F11407 		add	r7, r7, #20
 24751 0030 BD46     		mov	sp, r7
 24752 0032 80BC     		pop	{r7}
 24753 0034 7047     		bx	lr
 24754              	.L7:
 24755 0036 00BF     		.align	2
 24756              	.L6:
 24757 0038 00700040 		.word	1073770496
 24758              		.cfi_endproc
 24759              	.LFE112:
 24761              		.section	.text.PWR_PVDCmd,"ax",%progbits
 24762              		.align	2
 24763              		.global	PWR_PVDCmd
 24764              		.thumb
 24765              		.thumb_func
 24767              	PWR_PVDCmd:
 24768              	.LFB113:
 199:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 200:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 201:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Power Voltage Detector(PVD).
 202:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the PVD.
 203:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 204:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @retval None
 205:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 206:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** void PWR_PVDCmd(FunctionalState NewState)
 207:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** {
 24769              		.loc 1 207 0
 24770              		.cfi_startproc
 24771              		@ args = 0, pretend = 0, frame = 8
 24772              		@ frame_needed = 1, uses_anonymous_args = 0
 24773              		@ link register save eliminated.
 24774 0000 80B4     		push	{r7}
 24775              	.LCFI8:
 24776              		.cfi_def_cfa_offset 4
 24777 0002 83B0     		sub	sp, sp, #12
 24778              	.LCFI9:
 24779              		.cfi_def_cfa_offset 16
 24780 0004 00AF     		add	r7, sp, #0
 24781              		.cfi_offset 7, -4
 24782              	.LCFI10:
 24783              		.cfi_def_cfa_register 7
 24784 0006 0346     		mov	r3, r0
 24785 0008 FB71     		strb	r3, [r7, #7]
 208:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 209:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 210:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 211:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 24786              		.loc 1 211 0
 24787 000a 044B     		ldr	r3, .L9
 24788 000c FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 24789 000e 1A60     		str	r2, [r3, #0]
 212:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** }
 24790              		.loc 1 212 0
 24791 0010 07F10C07 		add	r7, r7, #12
 24792 0014 BD46     		mov	sp, r7
 24793 0016 80BC     		pop	{r7}
 24794 0018 7047     		bx	lr
 24795              	.L10:
 24796 001a 00BF     		.align	2
 24797              	.L9:
 24798 001c 10000E42 		.word	1108213776
 24799              		.cfi_endproc
 24800              	.LFE113:
 24802              		.section	.text.PWR_WakeUpPinCmd,"ax",%progbits
 24803              		.align	2
 24804              		.global	PWR_WakeUpPinCmd
 24805              		.thumb
 24806              		.thumb_func
 24808              	PWR_WakeUpPinCmd:
 24809              	.LFB114:
 213:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 214:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 215:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @}
 216:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 217:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 218:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group3 WakeUp pin configuration functions
 219:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *  @brief   WakeUp pin configuration functions 
 220:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *
 221:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @verbatim   
 222:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================
 223:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****                     WakeUp pin configuration functions
 224:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================  
 225:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 226:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  - WakeUp pin is used to wakeup the system from Standby mode. This pin is 
 227:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    forced in input pull down configuration and is active on rising edges.
 228:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  - There is only one WakeUp pin: WakeUp Pin 1 on PA.00.
 229:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 230:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @endverbatim
 231:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @{
 232:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 233:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 234:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 235:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the WakeUp Pin functionality.
 236:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the WakeUp Pin functionality.
 237:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 238:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @retval None
 239:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 240:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** void PWR_WakeUpPinCmd(FunctionalState NewState)
 241:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** {
 24810              		.loc 1 241 0
 24811              		.cfi_startproc
 24812              		@ args = 0, pretend = 0, frame = 8
 24813              		@ frame_needed = 1, uses_anonymous_args = 0
 24814              		@ link register save eliminated.
 24815 0000 80B4     		push	{r7}
 24816              	.LCFI11:
 24817              		.cfi_def_cfa_offset 4
 24818 0002 83B0     		sub	sp, sp, #12
 24819              	.LCFI12:
 24820              		.cfi_def_cfa_offset 16
 24821 0004 00AF     		add	r7, sp, #0
 24822              		.cfi_offset 7, -4
 24823              	.LCFI13:
 24824              		.cfi_def_cfa_register 7
 24825 0006 0346     		mov	r3, r0
 24826 0008 FB71     		strb	r3, [r7, #7]
 242:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Check the parameters */  
 243:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 244:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 245:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
 24827              		.loc 1 245 0
 24828 000a 044B     		ldr	r3, .L12
 24829 000c FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 24830 000e 1A60     		str	r2, [r3, #0]
 246:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** }
 24831              		.loc 1 246 0
 24832 0010 07F10C07 		add	r7, r7, #12
 24833 0014 BD46     		mov	sp, r7
 24834 0016 80BC     		pop	{r7}
 24835 0018 7047     		bx	lr
 24836              	.L13:
 24837 001a 00BF     		.align	2
 24838              	.L12:
 24839 001c A0000E42 		.word	1108213920
 24840              		.cfi_endproc
 24841              	.LFE114:
 24843              		.section	.text.PWR_BackupRegulatorCmd,"ax",%progbits
 24844              		.align	2
 24845              		.global	PWR_BackupRegulatorCmd
 24846              		.thumb
 24847              		.thumb_func
 24849              	PWR_BackupRegulatorCmd:
 24850              	.LFB115:
 247:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 248:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 249:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @}
 250:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 251:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 252:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group4 Main and Backup Regulators configuration functions
 253:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *  @brief   Main and Backup Regulators configuration functions 
 254:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *
 255:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @verbatim   
 256:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================
 257:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****                     Main and Backup Regulators configuration functions
 258:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================  
 259:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 260:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  - The backup domain includes 4 Kbytes of backup SRAM accessible only from the 
 261:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is retained 
 262:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    even in Standby or VBAT mode when the low power backup regulator is enabled. 
 263:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    It can be considered as an internal EEPROM when VBAT is always present.
 264:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    You can use the PWR_BackupRegulatorCmd() function to enable the low power
 265:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    backup regulator and use the PWR_GetFlagStatus(PWR_FLAG_BRR) to check if it is
 266:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    ready or not. 
 267:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 268:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  - When the backup domain is supplied by VDD (analog switch connected to VDD) 
 269:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    the backup SRAM is powered from VDD which replaces the VBAT power supply to 
 270:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    save battery life.
 271:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 272:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  - The backup SRAM is not mass erased by an tamper event. It is read protected 
 273:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    to prevent confidential data, such as cryptographic private key, from being 
 274:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    accessed. The backup SRAM can be erased only through the Flash interface when
 275:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    a protection level change from level 1 to level 0 is requested. 
 276:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    Refer to the description of Read protection (RDP) in the Flash programming manual.
 277:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 278:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  - The main internal regulator can be configured to have a tradeoff between performance
 279:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    and power consumption when the device does not operate at the maximum frequency. 
 280:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    This is done through PWR_MainRegulatorModeConfig() function which configure VOS bit
 281:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    in PWR_CR register: 
 282:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****       - When this bit is set (Regulator voltage output Scale 1 mode selected) the System
 283:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****         frequency can go up to 168 MHz. 
 284:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****       - When this bit is reset (Regulator voltage output Scale 2 mode selected) the System
 285:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****         frequency can go up to 144 MHz. 
 286:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    Refer to the datasheets for more details.
 287:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****            
 288:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @endverbatim
 289:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @{
 290:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 291:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 292:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 293:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Backup Regulator.
 294:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Backup Regulator.
 295:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 296:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @retval None
 297:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 298:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** void PWR_BackupRegulatorCmd(FunctionalState NewState)
 299:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** {
 24851              		.loc 1 299 0
 24852              		.cfi_startproc
 24853              		@ args = 0, pretend = 0, frame = 8
 24854              		@ frame_needed = 1, uses_anonymous_args = 0
 24855              		@ link register save eliminated.
 24856 0000 80B4     		push	{r7}
 24857              	.LCFI14:
 24858              		.cfi_def_cfa_offset 4
 24859 0002 83B0     		sub	sp, sp, #12
 24860              	.LCFI15:
 24861              		.cfi_def_cfa_offset 16
 24862 0004 00AF     		add	r7, sp, #0
 24863              		.cfi_offset 7, -4
 24864              	.LCFI16:
 24865              		.cfi_def_cfa_register 7
 24866 0006 0346     		mov	r3, r0
 24867 0008 FB71     		strb	r3, [r7, #7]
 300:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 301:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 302:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 303:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
 24868              		.loc 1 303 0
 24869 000a 044B     		ldr	r3, .L15
 24870 000c FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 24871 000e 1A60     		str	r2, [r3, #0]
 304:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** }
 24872              		.loc 1 304 0
 24873 0010 07F10C07 		add	r7, r7, #12
 24874 0014 BD46     		mov	sp, r7
 24875 0016 80BC     		pop	{r7}
 24876 0018 7047     		bx	lr
 24877              	.L16:
 24878 001a 00BF     		.align	2
 24879              	.L15:
 24880 001c A4000E42 		.word	1108213924
 24881              		.cfi_endproc
 24882              	.LFE115:
 24884              		.section	.text.PWR_MainRegulatorModeConfig,"ax",%progbits
 24885              		.align	2
 24886              		.global	PWR_MainRegulatorModeConfig
 24887              		.thumb
 24888              		.thumb_func
 24890              	PWR_MainRegulatorModeConfig:
 24891              	.LFB116:
 305:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 306:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 307:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief  Configures the main internal regulator output voltage.
 308:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  PWR_Regulator_Voltage: specifies the regulator output voltage to achieve
 309:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *         a tradeoff between performance and power consumption when the device does
 310:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *         not operate at the maximum frequency (refer to the datasheets for more details).
 311:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 312:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_Voltage_Scale1: Regulator voltage output Scale 1 mode, 
 313:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                                                System frequency up to 168 MHz. 
 314:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_Voltage_Scale2: Regulator voltage output Scale 2 mode, 
 315:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                                                System frequency up to 144 MHz.    
 316:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @retval None
 317:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 318:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
 319:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** {
 24892              		.loc 1 319 0
 24893              		.cfi_startproc
 24894              		@ args = 0, pretend = 0, frame = 8
 24895              		@ frame_needed = 1, uses_anonymous_args = 0
 24896              		@ link register save eliminated.
 24897 0000 80B4     		push	{r7}
 24898              	.LCFI17:
 24899              		.cfi_def_cfa_offset 4
 24900 0002 83B0     		sub	sp, sp, #12
 24901              	.LCFI18:
 24902              		.cfi_def_cfa_offset 16
 24903 0004 00AF     		add	r7, sp, #0
 24904              		.cfi_offset 7, -4
 24905              	.LCFI19:
 24906              		.cfi_def_cfa_register 7
 24907 0006 7860     		str	r0, [r7, #4]
 320:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 321:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));
 322:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 323:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   if (PWR_Regulator_Voltage == PWR_Regulator_Voltage_Scale2)
 24908              		.loc 1 323 0
 24909 0008 7B68     		ldr	r3, [r7, #4]
 24910 000a 002B     		cmp	r3, #0
 24911 000c 06D1     		bne	.L18
 324:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   {
 325:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     PWR->CR &= ~PWR_Regulator_Voltage_Scale1;
 24912              		.loc 1 325 0
 24913 000e 094B     		ldr	r3, .L20
 24914 0010 084A     		ldr	r2, .L20
 24915 0012 1268     		ldr	r2, [r2, #0]
 24916 0014 22F48042 		bic	r2, r2, #16384
 24917 0018 1A60     		str	r2, [r3, #0]
 24918 001a 05E0     		b	.L17
 24919              	.L18:
 326:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   }
 327:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   else
 328:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   {    
 329:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     PWR->CR |= PWR_Regulator_Voltage_Scale1;
 24920              		.loc 1 329 0
 24921 001c 054B     		ldr	r3, .L20
 24922 001e 054A     		ldr	r2, .L20
 24923 0020 1268     		ldr	r2, [r2, #0]
 24924 0022 42F48042 		orr	r2, r2, #16384
 24925 0026 1A60     		str	r2, [r3, #0]
 24926              	.L17:
 330:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   }
 331:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** }
 24927              		.loc 1 331 0
 24928 0028 07F10C07 		add	r7, r7, #12
 24929 002c BD46     		mov	sp, r7
 24930 002e 80BC     		pop	{r7}
 24931 0030 7047     		bx	lr
 24932              	.L21:
 24933 0032 00BF     		.align	2
 24934              	.L20:
 24935 0034 00700040 		.word	1073770496
 24936              		.cfi_endproc
 24937              	.LFE116:
 24939              		.section	.text.PWR_FlashPowerDownCmd,"ax",%progbits
 24940              		.align	2
 24941              		.global	PWR_FlashPowerDownCmd
 24942              		.thumb
 24943              		.thumb_func
 24945              	PWR_FlashPowerDownCmd:
 24946              	.LFB117:
 332:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 333:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 334:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @}
 335:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 336:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 337:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group5 FLASH Power Down configuration functions
 338:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *  @brief   FLASH Power Down configuration functions 
 339:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *
 340:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @verbatim   
 341:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================
 342:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****            FLASH Power Down configuration functions
 343:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================  
 344:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 345:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  - By setting the FPDS bit in the PWR_CR register by using the PWR_FlashPowerDownCmd()
 346:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    function, the Flash memory also enters power down mode when the device enters 
 347:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    Stop mode. When the Flash memory is in power down mode, an additional startup 
 348:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    delay is incurred when waking up from Stop mode.
 349:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 350:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @endverbatim
 351:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @{
 352:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 353:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 354:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 355:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Flash Power Down in STOP mode.
 356:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Flash power mode.
 357:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 358:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @retval None
 359:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 360:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** void PWR_FlashPowerDownCmd(FunctionalState NewState)
 361:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** {
 24947              		.loc 1 361 0
 24948              		.cfi_startproc
 24949              		@ args = 0, pretend = 0, frame = 8
 24950              		@ frame_needed = 1, uses_anonymous_args = 0
 24951              		@ link register save eliminated.
 24952 0000 80B4     		push	{r7}
 24953              	.LCFI20:
 24954              		.cfi_def_cfa_offset 4
 24955 0002 83B0     		sub	sp, sp, #12
 24956              	.LCFI21:
 24957              		.cfi_def_cfa_offset 16
 24958 0004 00AF     		add	r7, sp, #0
 24959              		.cfi_offset 7, -4
 24960              	.LCFI22:
 24961              		.cfi_def_cfa_register 7
 24962 0006 0346     		mov	r3, r0
 24963 0008 FB71     		strb	r3, [r7, #7]
 362:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 363:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 364:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 365:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
 24964              		.loc 1 365 0
 24965 000a 044B     		ldr	r3, .L23
 24966 000c FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 24967 000e 1A60     		str	r2, [r3, #0]
 366:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** }
 24968              		.loc 1 366 0
 24969 0010 07F10C07 		add	r7, r7, #12
 24970 0014 BD46     		mov	sp, r7
 24971 0016 80BC     		pop	{r7}
 24972 0018 7047     		bx	lr
 24973              	.L24:
 24974 001a 00BF     		.align	2
 24975              	.L23:
 24976 001c 24000E42 		.word	1108213796
 24977              		.cfi_endproc
 24978              	.LFE117:
 24980              		.section	.text.PWR_EnterSTOPMode,"ax",%progbits
 24981              		.align	2
 24982              		.global	PWR_EnterSTOPMode
 24983              		.thumb
 24984              		.thumb_func
 24986              	PWR_EnterSTOPMode:
 24987              	.LFB118:
 367:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 368:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 369:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @}
 370:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 371:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 372:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group6 Low Power modes configuration functions
 373:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *  @brief   Low Power modes configuration functions 
 374:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *
 375:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @verbatim   
 376:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================
 377:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****                     Low Power modes configuration functions
 378:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================  
 379:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 380:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   The devices feature 3 low-power modes:
 381:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    - Sleep mode: Cortex-M4 core stopped, peripherals kept running.
 382:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    - Stop mode: all clocks are stopped, regulator running, regulator in low power mode
 383:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    - Standby mode: 1.2V domain powered off.
 384:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    
 385:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    Sleep mode
 386:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    ===========
 387:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     - Entry:
 388:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****       - The Sleep mode is entered by using the __WFI() or __WFE() functions.
 389:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     - Exit:
 390:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****       - Any peripheral interrupt acknowledged by the nested vectored interrupt 
 391:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****         controller (NVIC) can wake up the device from Sleep mode.
 392:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 393:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    Stop mode
 394:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    ==========
 395:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    In Stop mode, all clocks in the 1.2V domain are stopped, the PLL, the HSI,
 396:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    and the HSE RC oscillators are disabled. Internal SRAM and register contents 
 397:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    are preserved.
 398:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    The voltage regulator can be configured either in normal or low-power mode.
 399:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    To minimize the consumption In Stop mode, FLASH can be powered off before 
 400:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    entering the Stop mode. It can be switched on again by software after exiting 
 401:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    the Stop mode using the PWR_FlashPowerDownCmd() function. 
 402:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    
 403:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     - Entry:
 404:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****       - The Stop mode is entered using the PWR_EnterSTOPMode(PWR_Regulator_LowPower,) 
 405:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****         function with regulator in LowPower or with Regulator ON.
 406:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     - Exit:
 407:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****       - Any EXTI Line (Internal or External) configured in Interrupt/Event mode.
 408:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****       
 409:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    Standby mode
 410:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    ============
 411:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    The Standby mode allows to achieve the lowest power consumption. It is based 
 412:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    on the Cortex-M4 deepsleep mode, with the voltage regulator disabled. 
 413:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    The 1.2V domain is consequently powered off. The PLL, the HSI oscillator and 
 414:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    the HSE oscillator are also switched off. SRAM and register contents are lost 
 415:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    except for the RTC registers, RTC backup registers, backup SRAM and Standby 
 416:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    circuitry.
 417:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    
 418:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    The voltage regulator is OFF.
 419:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****       
 420:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     - Entry:
 421:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****       - The Standby mode is entered using the PWR_EnterSTANDBYMode() function.
 422:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     - Exit:
 423:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****       - WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wakeup,
 424:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****         tamper event, time-stamp event, external reset in NRST pin, IWDG reset.              
 425:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 426:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    Auto-wakeup (AWU) from low-power mode
 427:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    =====================================
 428:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC 
 429:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    Wakeup event, a tamper event, a time-stamp event, or a comparator event, 
 430:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    without depending on an external interrupt (Auto-wakeup mode).
 431:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 432:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    - RTC auto-wakeup (AWU) from the Stop mode
 433:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****      ----------------------------------------
 434:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****      
 435:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****      - To wake up from the Stop mode with an RTC alarm event, it is necessary to:
 436:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Configure the EXTI Line 17 to be sensitive to rising edges (Interrupt 
 437:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          or Event modes) using the EXTI_Init() function.
 438:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
 439:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
 440:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          and RTC_AlarmCmd() functions.
 441:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****      - To wake up from the Stop mode with an RTC Tamper or time stamp event, it 
 442:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        is necessary to:
 443:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Configure the EXTI Line 21 to be sensitive to rising edges (Interrupt 
 444:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          or Event modes) using the EXTI_Init() function.
 445:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
 446:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          function
 447:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Configure the RTC to detect the tamper or time stamp event using the
 448:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
 449:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          functions.
 450:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****      - To wake up from the Stop mode with an RTC WakeUp event, it is necessary to:
 451:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Configure the EXTI Line 22 to be sensitive to rising edges (Interrupt 
 452:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          or Event modes) using the EXTI_Init() function.
 453:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
 454:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig(), 
 455:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
 456:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 457:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****    - RTC auto-wakeup (AWU) from the Standby mode
 458:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****      -------------------------------------------
 459:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****      - To wake up from the Standby mode with an RTC alarm event, it is necessary to:
 460:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
 461:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
 462:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          and RTC_AlarmCmd() functions.
 463:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****      - To wake up from the Standby mode with an RTC Tamper or time stamp event, it 
 464:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        is necessary to:
 465:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
 466:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          function
 467:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Configure the RTC to detect the tamper or time stamp event using the
 468:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
 469:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          functions.
 470:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****      - To wake up from the Standby mode with an RTC WakeUp event, it is necessary to:
 471:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
 472:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****        - Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig(), 
 473:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
 474:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 475:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @endverbatim
 476:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @{
 477:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 478:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 479:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 480:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief  Enters STOP mode.
 481:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *   
 482:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
 483:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
 484:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *         the HSI RC oscillator is selected as system clock.
 485:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @note   When the voltage regulator operates in low power mode, an additional 
 486:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
 487:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption 
 488:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *         is higher although the startup time is reduced.           
 489:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *     
 490:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  PWR_Regulator: specifies the regulator state in STOP mode.
 491:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 492:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_ON: STOP mode with regulator ON
 493:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_LowPower: STOP mode with regulator in low power mode
 494:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
 495:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 496:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
 497:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
 498:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @retval None
 499:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 500:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
 501:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** {
 24988              		.loc 1 501 0
 24989              		.cfi_startproc
 24990              		@ args = 0, pretend = 0, frame = 16
 24991              		@ frame_needed = 1, uses_anonymous_args = 0
 24992              		@ link register save eliminated.
 24993 0000 80B4     		push	{r7}
 24994              	.LCFI23:
 24995              		.cfi_def_cfa_offset 4
 24996 0002 85B0     		sub	sp, sp, #20
 24997              	.LCFI24:
 24998              		.cfi_def_cfa_offset 24
 24999 0004 00AF     		add	r7, sp, #0
 25000              		.cfi_offset 7, -4
 25001              	.LCFI25:
 25002              		.cfi_def_cfa_register 7
 25003 0006 7860     		str	r0, [r7, #4]
 25004 0008 0B46     		mov	r3, r1
 25005 000a FB70     		strb	r3, [r7, #3]
 502:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 25006              		.loc 1 502 0
 25007 000c 4FF00003 		mov	r3, #0
 25008 0010 FB60     		str	r3, [r7, #12]
 503:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 504:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 505:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_REGULATOR(PWR_Regulator));
 506:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
 507:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 508:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 509:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
 25009              		.loc 1 509 0
 25010 0012 134B     		ldr	r3, .L28
 25011 0014 1B68     		ldr	r3, [r3, #0]
 25012 0016 FB60     		str	r3, [r7, #12]
 510:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Clear PDDS and LPDSR bits */
 511:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   tmpreg &= CR_DS_MASK;
 25013              		.loc 1 511 0
 25014 0018 FB68     		ldr	r3, [r7, #12]
 25015 001a 23F00303 		bic	r3, r3, #3
 25016 001e FB60     		str	r3, [r7, #12]
 512:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 513:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Set LPDSR bit according to PWR_Regulator value */
 514:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   tmpreg |= PWR_Regulator;
 25017              		.loc 1 514 0
 25018 0020 FA68     		ldr	r2, [r7, #12]
 25019 0022 7B68     		ldr	r3, [r7, #4]
 25020 0024 42EA0303 		orr	r3, r2, r3
 25021 0028 FB60     		str	r3, [r7, #12]
 515:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 516:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Store the new value */
 517:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 25022              		.loc 1 517 0
 25023 002a 0D4B     		ldr	r3, .L28
 25024 002c FA68     		ldr	r2, [r7, #12]
 25025 002e 1A60     		str	r2, [r3, #0]
 518:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 519:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 520:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 25026              		.loc 1 520 0
 25027 0030 0C4B     		ldr	r3, .L28+4
 25028 0032 0C4A     		ldr	r2, .L28+4
 25029 0034 1269     		ldr	r2, [r2, #16]
 25030 0036 42F00402 		orr	r2, r2, #4
 25031 003a 1A61     		str	r2, [r3, #16]
 521:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 522:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 523:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 25032              		.loc 1 523 0
 25033 003c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 25034 003e 012B     		cmp	r3, #1
 25035 0040 01D1     		bne	.L26
 25036              	.LBB8:
 25037              	.LBB9:
   1:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /**************************************************************************//**
   2:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * @file     core_cmInstr.h
   3:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * @brief    CMSIS Cortex-M Core Instruction Access Header File
   4:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * @version  V2.10
   5:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * @date     19. July 2011
   6:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  *
   7:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * @note
   8:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * Copyright (C) 2009-2011 ARM Limited. All rights reserved.
   9:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  *
  10:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * @par
  11:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * ARM Limited (ARM) is supplying this software for use with Cortex-M 
  12:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * processor based microcontrollers.  This file can be freely distributed 
  13:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * within development tools that are supporting such ARM based processors. 
  14:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  *
  15:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * @par
  16:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
  17:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
  18:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
  19:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
  20:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
  21:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  *
  22:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  ******************************************************************************/
  23:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  24:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #ifndef __CORE_CMINSTR_H
  25:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __CORE_CMINSTR_H
  26:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  27:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  28:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /* ##########################  Core Instruction Access  ######################### */
  29:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  30:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****   Access to dedicated instructions
  31:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****   @{
  32:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** */
  33:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  34:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  35:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /* ARM armcc specific functions */
  36:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  37:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #if (__ARMCC_VERSION < 400677)
  38:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  39:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #endif
  40:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  41:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  42:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  No Operation
  43:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  44:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
  45:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
  46:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __NOP                             __nop
  47:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  48:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  49:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Wait For Interrupt
  50:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  51:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
  52:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     until one of a number of events occurs.
  53:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
  54:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __WFI                             __wfi
  55:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  56:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  57:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Wait For Event
  58:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  59:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
  60:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
  61:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
  62:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __WFE                             __wfe
  63:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  64:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  65:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Send Event
  66:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  67:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
  68:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
  69:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __SEV                             __sev
  70:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  71:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  72:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Instruction Synchronization Barrier
  73:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  74:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     Instruction Synchronization Barrier flushes the pipeline in the processor, 
  75:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     so that all instructions following the ISB are fetched from cache or 
  76:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     memory, after the instruction has been completed.
  77:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
  78:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __ISB()                           __isb(0xF)
  79:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  80:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  81:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Data Synchronization Barrier
  82:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  83:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function acts as a special kind of Data Memory Barrier. 
  84:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     It completes when all explicit memory accesses before this instruction complete.
  85:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
  86:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __DSB()                           __dsb(0xF)
  87:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  88:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  89:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Data Memory Barrier
  90:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  91:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function ensures the apparent order of the explicit memory operations before 
  92:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     and after the instruction, without ensuring their completion.
  93:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
  94:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __DMB()                           __dmb(0xF)
  95:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  96:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  97:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Reverse byte order (32 bit)
  98:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
  99:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function reverses the byte order in integer value.
 100:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 101:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]    value  Value to reverse
 102:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return               Reversed value
 103:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 104:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __REV                             __rev
 105:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 106:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 107:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Reverse byte order (16 bit)
 108:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 109:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function reverses the byte order in two unsigned short values.
 110:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 111:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]    value  Value to reverse
 112:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return               Reversed value
 113:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 114:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** static __INLINE __ASM uint32_t __REV16(uint32_t value)
 115:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** {
 116:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****   rev16 r0, r0
 117:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****   bx lr
 118:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** }
 119:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 120:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 121:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Reverse byte order in signed short value
 122:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 123:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function reverses the byte order in a signed short value with sign extension to integer.
 124:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 125:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]    value  Value to reverse
 126:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return               Reversed value
 127:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 128:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** static __INLINE __ASM int32_t __REVSH(int32_t value)
 129:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** {
 130:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****   revsh r0, r0
 131:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****   bx lr
 132:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** }
 133:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 134:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 135:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #if       (__CORTEX_M >= 0x03)
 136:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 137:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Reverse bit order of value
 138:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 139:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function reverses the bit order of the given value.
 140:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 141:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]    value  Value to reverse
 142:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return               Reversed value
 143:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 144:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __RBIT                            __rbit
 145:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 146:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 147:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  LDR Exclusive (8 bit)
 148:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 149:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function performs a exclusive LDR command for 8 bit value.
 150:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 151:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 152:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return             value of type uint8_t at (*ptr)
 153:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 154:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
 155:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 156:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 157:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  LDR Exclusive (16 bit)
 158:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 159:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function performs a exclusive LDR command for 16 bit values.
 160:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 161:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 162:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return        value of type uint16_t at (*ptr)
 163:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 164:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
 165:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 166:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 167:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  LDR Exclusive (32 bit)
 168:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 169:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function performs a exclusive LDR command for 32 bit values.
 170:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 171:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 172:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return        value of type uint32_t at (*ptr)
 173:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 174:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
 175:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 176:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 177:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  STR Exclusive (8 bit)
 178:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 179:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function performs a exclusive STR command for 8 bit values.
 180:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 181:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]  value  Value to store
 182:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 183:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return          0  Function succeeded
 184:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return          1  Function failed
 185:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 186:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __STREXB(value, ptr)              __strex(value, ptr)
 187:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 188:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 189:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  STR Exclusive (16 bit)
 190:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 191:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function performs a exclusive STR command for 16 bit values.
 192:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 193:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]  value  Value to store
 194:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 195:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return          0  Function succeeded
 196:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return          1  Function failed
 197:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 198:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __STREXH(value, ptr)              __strex(value, ptr)
 199:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 200:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 201:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  STR Exclusive (32 bit)
 202:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 203:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function performs a exclusive STR command for 32 bit values.
 204:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 205:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]  value  Value to store
 206:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 207:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return          0  Function succeeded
 208:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return          1  Function failed
 209:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 210:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __STREXW(value, ptr)              __strex(value, ptr)
 211:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 212:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 213:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Remove the exclusive lock
 214:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 215:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function removes the exclusive lock which is created by LDREX.
 216:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 217:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 218:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __CLREX                           __clrex
 219:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 220:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 221:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Signed Saturate
 222:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 223:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function saturates a signed value.
 224:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 225:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 226:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (1..32)
 227:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return             Saturated value
 228:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 229:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __SSAT                            __ssat
 230:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 231:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 232:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Unsigned Saturate
 233:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 234:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function saturates an unsigned value.
 235:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 236:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 237:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (0..31)
 238:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return             Saturated value
 239:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 240:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __USAT                            __usat
 241:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 242:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 243:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Count leading zeros
 244:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 245:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     This function counts the number of leading zeros of a data value.
 246:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 247:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \param [in]  value  Value to count the leading zeros
 248:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     \return             number of leading zeros in value
 249:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 250:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #define __CLZ                             __clz 
 251:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 252:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #endif /* (__CORTEX_M >= 0x03) */
 253:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 254:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 255:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 256:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 257:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /* IAR iccarm specific functions */
 258:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 259:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #include <cmsis_iar.h>
 260:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 261:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 262:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 263:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /* GNU gcc specific functions */
 264:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 265:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  No Operation
 266:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 267:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
 268:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 269:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** __attribute__( ( always_inline ) ) static __INLINE void __NOP(void)
 270:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** {
 271:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****   __ASM volatile ("nop");
 272:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** }
 273:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 274:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 275:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Wait For Interrupt
 276:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 277:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
 278:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     until one of a number of events occurs.
 279:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 280:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** __attribute__( ( always_inline ) ) static __INLINE void __WFI(void)
 281:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** {
 282:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****   __ASM volatile ("wfi");
 25038              		.loc 7 282 0
 25039              	@ 282 "/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h" 1
 25040 0042 30BF     		wfi
 25041              	@ 0 "" 2
 25042              		.thumb
 25043 0044 00E0     		b	.L27
 25044              	.L26:
 25045              	.LBE9:
 25046              	.LBE8:
 25047              	.LBB10:
 25048              	.LBB11:
 283:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** }
 284:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 285:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 286:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** /** \brief  Wait For Event
 287:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** 
 288:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
 289:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
 290:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****  */
 291:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** __attribute__( ( always_inline ) ) static __INLINE void __WFE(void)
 292:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h **** {
 293:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****   __ASM volatile ("wfe");
 25049              		.loc 7 293 0
 25050              	@ 293 "/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h" 1
 25051 0046 20BF     		wfe
 25052              	@ 0 "" 2
 25053              		.thumb
 25054              	.L27:
 25055              	.LBE11:
 25056              	.LBE10:
 524:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   {   
 525:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     /* Request Wait For Interrupt */
 526:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     __WFI();
 527:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   }
 528:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   else
 529:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   {
 530:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     /* Request Wait For Event */
 531:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     __WFE();
 532:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   }
 533:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 534:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 25057              		.loc 1 534 0
 25058 0048 064B     		ldr	r3, .L28+4
 25059 004a 064A     		ldr	r2, .L28+4
 25060 004c 1269     		ldr	r2, [r2, #16]
 25061 004e 22F00402 		bic	r2, r2, #4
 25062 0052 1A61     		str	r2, [r3, #16]
 535:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** }
 25063              		.loc 1 535 0
 25064 0054 07F11407 		add	r7, r7, #20
 25065 0058 BD46     		mov	sp, r7
 25066 005a 80BC     		pop	{r7}
 25067 005c 7047     		bx	lr
 25068              	.L29:
 25069 005e 00BF     		.align	2
 25070              	.L28:
 25071 0060 00700040 		.word	1073770496
 25072 0064 00ED00E0 		.word	-536810240
 25073              		.cfi_endproc
 25074              	.LFE118:
 25076              		.section	.text.PWR_EnterSTANDBYMode,"ax",%progbits
 25077              		.align	2
 25078              		.global	PWR_EnterSTANDBYMode
 25079              		.thumb
 25080              		.thumb_func
 25082              	PWR_EnterSTANDBYMode:
 25083              	.LFB119:
 536:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 537:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 538:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief  Enters STANDBY mode.
 539:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @note   In Standby mode, all I/O pins are high impedance except for:
 540:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          - Reset pad (still available) 
 541:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          - RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC 
 542:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            Alarm out, or RTC clock calibration out.
 543:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          - RTC_AF2 pin (PI8) if configured for tamper or time-stamp.  
 544:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          - WKUP pin 1 (PA0) if enabled.       
 545:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  None
 546:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @retval None
 547:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 548:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** void PWR_EnterSTANDBYMode(void)
 549:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** {
 25084              		.loc 1 549 0
 25085              		.cfi_startproc
 25086              		@ args = 0, pretend = 0, frame = 0
 25087              		@ frame_needed = 1, uses_anonymous_args = 0
 25088              		@ link register save eliminated.
 25089 0000 80B4     		push	{r7}
 25090              	.LCFI26:
 25091              		.cfi_def_cfa_offset 4
 25092 0002 00AF     		add	r7, sp, #0
 25093              		.cfi_offset 7, -4
 25094              	.LCFI27:
 25095              		.cfi_def_cfa_register 7
 550:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Clear Wakeup flag */
 551:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   PWR->CR |= PWR_CR_CWUF;
 25096              		.loc 1 551 0
 25097 0004 0A4B     		ldr	r3, .L31
 25098 0006 0A4A     		ldr	r2, .L31
 25099 0008 1268     		ldr	r2, [r2, #0]
 25100 000a 42F00402 		orr	r2, r2, #4
 25101 000e 1A60     		str	r2, [r3, #0]
 552:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 553:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Select STANDBY mode */
 554:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   PWR->CR |= PWR_CR_PDDS;
 25102              		.loc 1 554 0
 25103 0010 074B     		ldr	r3, .L31
 25104 0012 074A     		ldr	r2, .L31
 25105 0014 1268     		ldr	r2, [r2, #0]
 25106 0016 42F00202 		orr	r2, r2, #2
 25107 001a 1A60     		str	r2, [r3, #0]
 555:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 556:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 557:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 25108              		.loc 1 557 0
 25109 001c 054B     		ldr	r3, .L31+4
 25110 001e 054A     		ldr	r2, .L31+4
 25111 0020 1269     		ldr	r2, [r2, #16]
 25112 0022 42F00402 		orr	r2, r2, #4
 25113 0026 1A61     		str	r2, [r3, #16]
 25114              	.LBB12:
 25115              	.LBB13:
 282:/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h ****   __ASM volatile ("wfi");
 25116              		.loc 7 282 0
 25117              	@ 282 "/home/kvv/workspace/k-car/autopilot/inc/CMSIS/core_cmInstr.h" 1
 25118 0028 30BF     		wfi
 25119              	@ 0 "" 2
 25120              		.thumb
 25121              	.LBE13:
 25122              	.LBE12:
 558:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 559:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /* This option is used to ensure that store operations are completed */
 560:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #if defined ( __CC_ARM   )
 561:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   __force_stores();
 562:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** #endif
 563:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Request Wait For Interrupt */
 564:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   __WFI();
 565:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** }
 25123              		.loc 1 565 0
 25124 002a BD46     		mov	sp, r7
 25125 002c 80BC     		pop	{r7}
 25126 002e 7047     		bx	lr
 25127              	.L32:
 25128              		.align	2
 25129              	.L31:
 25130 0030 00700040 		.word	1073770496
 25131 0034 00ED00E0 		.word	-536810240
 25132              		.cfi_endproc
 25133              	.LFE119:
 25135              		.section	.text.PWR_GetFlagStatus,"ax",%progbits
 25136              		.align	2
 25137              		.global	PWR_GetFlagStatus
 25138              		.thumb
 25139              		.thumb_func
 25141              	PWR_GetFlagStatus:
 25142              	.LFB120:
 566:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 567:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 568:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @}
 569:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 570:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 571:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group7 Flags management functions
 572:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *  @brief   Flags management functions 
 573:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  *
 574:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @verbatim   
 575:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================
 576:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****                            Flags management functions
 577:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****  ===============================================================================  
 578:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 579:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** @endverbatim
 580:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @{
 581:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 582:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 583:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 584:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief  Checks whether the specified PWR flag is set or not.
 585:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  PWR_FLAG: specifies the flag to check.
 586:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 587:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event 
 588:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                  was received from the WKUP pin or from the RTC alarm (Alarm A 
 589:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                  or Alarm B), RTC Tamper event, RTC TimeStamp event or RTC Wakeup.
 590:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                  An additional wakeup event is detected if the WKUP pin is enabled 
 591:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                  (by setting the EWUP bit) when the WKUP pin level is already high.  
 592:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
 593:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                  resumed from StandBy mode.    
 594:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled 
 595:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                  by the PWR_PVDCmd() function. The PVD is stopped by Standby mode 
 596:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                  For this reason, this bit is equal to 0 after Standby or reset
 597:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                  until the PVDE bit is set.
 598:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_BRR: Backup regulator ready flag. This bit is not reset 
 599:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                  when the device wakes up from Standby mode or by a system reset 
 600:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                  or power reset.  
 601:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
 602:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *                 scaling output selection is ready. 
 603:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @retval The new state of PWR_FLAG (SET or RESET).
 604:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 605:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
 606:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** {
 25143              		.loc 1 606 0
 25144              		.cfi_startproc
 25145              		@ args = 0, pretend = 0, frame = 16
 25146              		@ frame_needed = 1, uses_anonymous_args = 0
 25147              		@ link register save eliminated.
 25148 0000 80B4     		push	{r7}
 25149              	.LCFI28:
 25150              		.cfi_def_cfa_offset 4
 25151 0002 85B0     		sub	sp, sp, #20
 25152              	.LCFI29:
 25153              		.cfi_def_cfa_offset 24
 25154 0004 00AF     		add	r7, sp, #0
 25155              		.cfi_offset 7, -4
 25156              	.LCFI30:
 25157              		.cfi_def_cfa_register 7
 25158 0006 7860     		str	r0, [r7, #4]
 607:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   FlagStatus bitstatus = RESET;
 25159              		.loc 1 607 0
 25160 0008 4FF00003 		mov	r3, #0
 25161 000c FB73     		strb	r3, [r7, #15]
 608:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 609:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 610:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
 611:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   
 612:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 25162              		.loc 1 612 0
 25163 000e 0A4B     		ldr	r3, .L36
 25164 0010 5A68     		ldr	r2, [r3, #4]
 25165 0012 7B68     		ldr	r3, [r7, #4]
 25166 0014 02EA0303 		and	r3, r2, r3
 25167 0018 002B     		cmp	r3, #0
 25168 001a 03D0     		beq	.L34
 613:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   {
 614:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     bitstatus = SET;
 25169              		.loc 1 614 0
 25170 001c 4FF00103 		mov	r3, #1
 25171 0020 FB73     		strb	r3, [r7, #15]
 25172 0022 02E0     		b	.L35
 25173              	.L34:
 615:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   }
 616:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   else
 617:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   {
 618:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****     bitstatus = RESET;
 25174              		.loc 1 618 0
 25175 0024 4FF00003 		mov	r3, #0
 25176 0028 FB73     		strb	r3, [r7, #15]
 25177              	.L35:
 619:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   }
 620:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Return the flag status */
 621:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   return bitstatus;
 25178              		.loc 1 621 0
 25179 002a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 622:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** }
 25180              		.loc 1 622 0
 25181 002c 1846     		mov	r0, r3
 25182 002e 07F11407 		add	r7, r7, #20
 25183 0032 BD46     		mov	sp, r7
 25184 0034 80BC     		pop	{r7}
 25185 0036 7047     		bx	lr
 25186              	.L37:
 25187              		.align	2
 25188              	.L36:
 25189 0038 00700040 		.word	1073770496
 25190              		.cfi_endproc
 25191              	.LFE120:
 25193              		.section	.text.PWR_ClearFlag,"ax",%progbits
 25194              		.align	2
 25195              		.global	PWR_ClearFlag
 25196              		.thumb
 25197              		.thumb_func
 25199              	PWR_ClearFlag:
 25200              	.LFB121:
 623:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** 
 624:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** /**
 625:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @brief  Clears the PWR's pending flags.
 626:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @param  PWR_FLAG: specifies the flag to clear.
 627:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 628:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_WU: Wake Up flag
 629:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_SB: StandBy flag
 630:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   * @retval None
 631:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   */
 632:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** void PWR_ClearFlag(uint32_t PWR_FLAG)
 633:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** {
 25201              		.loc 1 633 0
 25202              		.cfi_startproc
 25203              		@ args = 0, pretend = 0, frame = 8
 25204              		@ frame_needed = 1, uses_anonymous_args = 0
 25205              		@ link register save eliminated.
 25206 0000 80B4     		push	{r7}
 25207              	.LCFI31:
 25208              		.cfi_def_cfa_offset 4
 25209 0002 83B0     		sub	sp, sp, #12
 25210              	.LCFI32:
 25211              		.cfi_def_cfa_offset 16
 25212 0004 00AF     		add	r7, sp, #0
 25213              		.cfi_offset 7, -4
 25214              	.LCFI33:
 25215              		.cfi_def_cfa_register 7
 25216 0006 7860     		str	r0, [r7, #4]
 634:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 635:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
 636:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****          
 637:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c ****   PWR->CR |=  PWR_FLAG << 2;
 25217              		.loc 1 637 0
 25218 0008 064B     		ldr	r3, .L39
 25219 000a 064A     		ldr	r2, .L39
 25220 000c 1168     		ldr	r1, [r2, #0]
 25221 000e 7A68     		ldr	r2, [r7, #4]
 25222 0010 4FEA8202 		lsl	r2, r2, #2
 25223 0014 41EA0202 		orr	r2, r1, r2
 25224 0018 1A60     		str	r2, [r3, #0]
 638:../inc/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c **** }
 25225              		.loc 1 638 0
 25226 001a 07F10C07 		add	r7, r7, #12
 25227 001e BD46     		mov	sp, r7
 25228 0020 80BC     		pop	{r7}
 25229 0022 7047     		bx	lr
 25230              	.L40:
 25231              		.align	2
 25232              	.L39:
 25233 0024 00700040 		.word	1073770496
 25234              		.cfi_endproc
 25235              	.LFE121:
 25237              		.text
 25238              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f4xx_pwr.c
     /tmp/cc36Uzj0.s:24632  .text.PWR_DeInit:00000000 $t
     /tmp/cc36Uzj0.s:24637  .text.PWR_DeInit:00000000 PWR_DeInit
     /tmp/cc36Uzj0.s:24665  .text.PWR_BackupAccessCmd:00000000 $t
     /tmp/cc36Uzj0.s:24670  .text.PWR_BackupAccessCmd:00000000 PWR_BackupAccessCmd
     /tmp/cc36Uzj0.s:24701  .text.PWR_BackupAccessCmd:0000001c $d
     /tmp/cc36Uzj0.s:24706  .text.PWR_PVDLevelConfig:00000000 $t
     /tmp/cc36Uzj0.s:24711  .text.PWR_PVDLevelConfig:00000000 PWR_PVDLevelConfig
     /tmp/cc36Uzj0.s:24757  .text.PWR_PVDLevelConfig:00000038 $d
     /tmp/cc36Uzj0.s:24762  .text.PWR_PVDCmd:00000000 $t
     /tmp/cc36Uzj0.s:24767  .text.PWR_PVDCmd:00000000 PWR_PVDCmd
     /tmp/cc36Uzj0.s:24798  .text.PWR_PVDCmd:0000001c $d
     /tmp/cc36Uzj0.s:24803  .text.PWR_WakeUpPinCmd:00000000 $t
     /tmp/cc36Uzj0.s:24808  .text.PWR_WakeUpPinCmd:00000000 PWR_WakeUpPinCmd
     /tmp/cc36Uzj0.s:24839  .text.PWR_WakeUpPinCmd:0000001c $d
     /tmp/cc36Uzj0.s:24844  .text.PWR_BackupRegulatorCmd:00000000 $t
     /tmp/cc36Uzj0.s:24849  .text.PWR_BackupRegulatorCmd:00000000 PWR_BackupRegulatorCmd
     /tmp/cc36Uzj0.s:24880  .text.PWR_BackupRegulatorCmd:0000001c $d
     /tmp/cc36Uzj0.s:24885  .text.PWR_MainRegulatorModeConfig:00000000 $t
     /tmp/cc36Uzj0.s:24890  .text.PWR_MainRegulatorModeConfig:00000000 PWR_MainRegulatorModeConfig
     /tmp/cc36Uzj0.s:24935  .text.PWR_MainRegulatorModeConfig:00000034 $d
     /tmp/cc36Uzj0.s:24940  .text.PWR_FlashPowerDownCmd:00000000 $t
     /tmp/cc36Uzj0.s:24945  .text.PWR_FlashPowerDownCmd:00000000 PWR_FlashPowerDownCmd
     /tmp/cc36Uzj0.s:24976  .text.PWR_FlashPowerDownCmd:0000001c $d
     /tmp/cc36Uzj0.s:24981  .text.PWR_EnterSTOPMode:00000000 $t
     /tmp/cc36Uzj0.s:24986  .text.PWR_EnterSTOPMode:00000000 PWR_EnterSTOPMode
     /tmp/cc36Uzj0.s:25071  .text.PWR_EnterSTOPMode:00000060 $d
     /tmp/cc36Uzj0.s:25077  .text.PWR_EnterSTANDBYMode:00000000 $t
     /tmp/cc36Uzj0.s:25082  .text.PWR_EnterSTANDBYMode:00000000 PWR_EnterSTANDBYMode
     /tmp/cc36Uzj0.s:25130  .text.PWR_EnterSTANDBYMode:00000030 $d
     /tmp/cc36Uzj0.s:25136  .text.PWR_GetFlagStatus:00000000 $t
     /tmp/cc36Uzj0.s:25141  .text.PWR_GetFlagStatus:00000000 PWR_GetFlagStatus
     /tmp/cc36Uzj0.s:25189  .text.PWR_GetFlagStatus:00000038 $d
     /tmp/cc36Uzj0.s:25194  .text.PWR_ClearFlag:00000000 $t
     /tmp/cc36Uzj0.s:25199  .text.PWR_ClearFlag:00000000 PWR_ClearFlag
     /tmp/cc36Uzj0.s:25233  .text.PWR_ClearFlag:00000024 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
RCC_APB1PeriphResetCmd
